#TODO- add author date
##TODO- add role of class and functions retails
from dotenv import load_dotenv
from langchain_core.runnables import RunnableLambda, RunnablePassthrough, RunnableParallel
from apps.langchain_bot.dependencies import document_retriever, llm, database_information_retrieval
from typing import Dict, Any
from langchain_community.tools.sql_database.tool import QuerySQLDataBaseTool
from langchain_core.runnables.utils import AddableDict

#TODO- add comments ; role and what this function is doing
def get_context(inputs: Dict[str, Any]) -> str:
    """
    Retrieves the top k tables based on the user's query and formats them as a string.

    Args:
        inputs (Dict[str, Any]): A dictionary containing the user's query under the key "question".

    Returns:
        str: A formatted string representation of the top k tables related to the query.
    """
    context = document_retriever.find_top_k_similar(inputs["question"], k=3)
    return context

#TODO- add comments ; role and what this function is doing

def create_final_prompt(question: str, context: str) -> str:
    final_prompt = f"""
    You are a PostgreSQL expert. Based on the input question, generate a syntactically correct PostgreSQL query that strictly adheres to the following rules:  
    - Return only the generated query, with no additional text.  
    - Remember NOT include backticks ```sql ``` before and after the created query. 

    Context: Use only the table names and column names provided in: {context}. Ensure the query accurately reflects the structure of these tables.  

    Guidelines:  
    1. If the context contains multiple tables, use a `JOIN` operation based on the column `unitid`.  
    2. Avoid querying columns that are not present in the tables.  
    3. Use aliases only when necessary.  
    4. Pay close attention to which columns belong to which table to ensure correctness.  

    User question: {question['question']}
    History Message: {question['messages']}
    """
    output = AddableDict({'question':question['question'], 'messages': question['messages'], 'final_prompt': final_prompt})
    return output

#TODO- add comments ; role and what this function is doing
def generate_sql_llm(inputs: Dict[str, Any]) -> str:
    """
    Generates SQL code using the provided final prompt.

    Args:
        final_prompt (str): The complete prompt including the question and context.

    Returns:
        str: The SQL query generated by the LLM.
    """
    sql_query = llm.invoke(inputs['final_prompt'])
    del inputs['final_prompt']
    del inputs['messages']
    output = inputs + AddableDict({'sql_query': sql_query})
    return output

#TODO- add comments ; role and what this function is doing
def get_query_results(inputs: Dict[str, Any]) -> Any:
    """
    Executes the provided SQL query and returns the results.

    Args:
        sql_query (str): The SQL query to execute.

    Returns:
        str: The results of the query (mocked as "25 students").
    """
    execute_query = (RunnablePassthrough.assign(
            result=RunnableLambda(lambda x: inputs['sql_query']) | QuerySQLDataBaseTool(db=database_information_retrieval)
        )
    )
    query_results = execute_query.invoke({})
    output = inputs +  AddableDict({'query_results': query_results['result']})
    return output

#TODO- add comments ; role and what this function is doing
def rephrase_query_results(inputs: Dict[str, Any]) -> str:
    
    answer_prompt=f"""Given the following user question, corresponding SQL query, and SQL result, provide answer for the user question.
        User Question: {inputs['question']}
        SQL Query: {inputs['sql_query']}
        SQL Result: {inputs['query_results']}
        Answer: """
    return llm.invoke(answer_prompt)


# Wrap functions with RunnableLambda
get_context_runnable = RunnableLambda(get_context)
create_final_prompt_runnable = RunnableLambda(lambda inputs: create_final_prompt(**inputs))
generate_sql_llm_runnable = RunnableLambda(generate_sql_llm)
get_query_results_runnable = RunnableLambda(get_query_results)
rephrase_query_results_runnable = RunnableLambda(rephrase_query_results)

# Compose the chain using the pipe operator
chain = (
        RunnableParallel({
            "context": get_context_runnable,
            "question": RunnablePassthrough(),
        })
        | create_final_prompt_runnable
        | generate_sql_llm_runnable
        | get_query_results_runnable
        | rephrase_query_results_runnable
)
